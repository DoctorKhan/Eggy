<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Good Knight Birdy</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0a0a0a;
            font-family: 'Press-Start-2P', cursive;
            color: white;
            overflow: hidden;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            border: 4px solid #444;
            border-radius: 10px;
            background: #111;
            padding: 20px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }
        canvas {
            background-color: #000;
            border: 2px solid #55e;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(85, 85, 238, 0.5);
            max-width: 100%;
            max-height: 80vh;
            aspect-ratio: 4 / 3;
            cursor: pointer;
        }
        .controls {
            margin-top: 15px;
            font-size: 1em;
            color: #ccc;
        }
        .score-board {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #ffcc00;
            text-shadow: 2px 2px #d40000;
        }
    </style>
</head>
<body>

<div class="game-container">
    <div id="score-board" class="score-board">SCORE: 0 | WAVE: 1 | LIVES: 3</div>
    <div id="game-over" style="display:none; color:#ff4444; font-size:2em; margin-top:20px;">GAME OVER!<br>Press R to restart.</div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">Click Screen to Start Sound | Arrows: ← Left | → Right | ↑ Flap</div>
</div>

<script>
    // --- Canvas and Context Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('score-board');

    // --- Game Constants ---
    const GRAVITY = 0.3;
    const FLAP_FORCE = -7;
    const MOVE_SPEED = 4;
    const FRICTION = 0.92;
    const RESPAWN_TIME = 2000; 
    const EGG_HATCH_TIME = 5000;

    // --- Game State ---
    let platforms = [];
    let player;
    let powerUps = [];
    let enemies = [];
    let eggs = [];
    let particles = [];
    let score = 0;
    let wave = 1;
    let lives = 3;
    let gameOver = false;
    let frameCount = 0;
    let soundReady = false;
    let lastFlapTime = 0;
    let playerSpeedBoost = 1;
    let playerShielded = false;
    let playerShieldTimer = 0;
    let playerDoublePoints = false;
    let playerDoubleTimer = 0;
    let playerMegaFlap = false;
    let playerMegaFlapTimer = 0;
    let speedBoostTimer = 0;
    let waveMessage = { text: "GET READY!", alpha: 1, timer: 120 };

    // --- Sound Engine (with Pooling and Reverb) ---
    const sound = {
        reverb: null,
        defeatSoundPool: [],
        poolIndex: 0,
        flapSynth: null,
        eggSynth: null,
        playerDefeatSynth: null,

        init() {
            this.reverb = new Tone.Reverb({ decay: 1.5, wet: 0.2 }).toDestination();
            this.flapSynth = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 4, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
            this.eggSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 } }).connect(this.reverb);
            this.playerDefeatSynth = new Tone.MetalSynth({ frequency: 100, envelope: { attack: 0.001, decay: 0.4, release: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).connect(this.reverb);

            for (let i = 0; i < 5; i++) {
                const noise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).connect(this.reverb);
                const metal = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.1, release: 0.05 }, harmonicity: 3.1, modulationIndex: 16, resonance: 2000, octaves: 1.5 }).connect(this.reverb);
                this.defeatSoundPool.push({ noise, metal });
            }
        },

        playFlap: () => {
            if (!soundReady) return;
            const now = Tone.now();
            if (now > lastFlapTime + 0.05) {
                sound.flapSynth.triggerAttackRelease('C2', '8n', now);
                lastFlapTime = now;
            }
        },
        playDefeat: () => {
            if (!soundReady) return;
            const synths = sound.defeatSoundPool[sound.poolIndex];
            synths.noise.triggerAttackRelease("0.1");
            synths.metal.triggerAttackRelease("C4", "0.1");
            sound.poolIndex = (sound.poolIndex + 1) % sound.defeatSoundPool.length;
        },
        playEggCollect: () => { if(soundReady) sound.eggSynth.triggerAttackRelease('G5', '8n'); },
        playPlayerDefeat: () => { if(soundReady) sound.playerDefeatSynth.triggerAttackRelease(0.2); }
    };
    
    canvas.addEventListener('click', async () => {
        if (!soundReady) {
            await Tone.start();
            sound.init();
            soundReady = true;
            console.log('Audio is ready');
        }
    });

    // --- Utility Functions ---
    function randomRange(min, max) { return Math.random() * (max - min) + min; }

    // --- Game Object Classes ---
    class Particle {
        constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.size = Math.random() * 5 + 2; this.dx = randomRange(-3, 3); this.dy = randomRange(-5, 2); this.life = 1; }
        update() { this.x += this.dx; this.y += this.dy; this.dy += GRAVITY * 0.5; this.life -= 0.03; }
        draw() { ctx.fillStyle = `rgba(${this.color}, ${this.life})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
    }
    
    class Egg {
        constructor(x, y) { this.x = x; this.y = y; this.width = 15; this.height = 20; this.dx = randomRange(-2, 2); this.dy = -2; this.hatchTimer = EGG_HATCH_TIME; }
        update() {
            this.dy += GRAVITY; this.x += this.dx; this.y += this.dy; this.dx *= 0.98;
            platforms.forEach(p => { if (this.y+this.height>p.y && this.y<p.y+p.height && this.x+this.width>p.x && this.x<p.x+p.width) { if (this.dy > 0) { this.y = p.y - this.height; this.dy *= -0.5; } } });
            if (this.y > canvas.height - this.height - 20) { this.y = canvas.height - this.height - 20; this.dy *= -0.5; }
            if (this.x > canvas.width) this.x = 0; if (this.x < 0) this.x = canvas.width;
            this.hatchTimer -= 1000 / 60;
            if (this.hatchTimer <= 0) this.hatch();
        }
        draw() { ctx.fillStyle = '#E0E0E0'; ctx.strokeStyle = '#A0A0A0'; ctx.lineWidth = 2; ctx.beginPath(); ctx.ellipse(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, this.height / 2, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); }
        hatch() { enemies.push(new Knight(this.x, this.y, 'enemy')); const index = eggs.indexOf(this); if (index > -1) eggs.splice(index, 1); }
    }

    class PowerUp {
        constructor(x, y, type) { this.x = x; this.y = y; this.size = 18; this.type = type; this.dy = -2; }
        update() {
            this.dy += GRAVITY; this.y += this.dy;
            let onPlatform = false;
            for (let p of platforms) { if (this.x > p.x && this.x < p.x + p.width && this.y + this.size > p.y && this.y < p.y + p.height) { this.y = p.y - this.size; this.dy = 0; onPlatform = true; break; } }
            if (!onPlatform) { const floorY = canvas.height - 20 - this.size; if (this.y > floorY) { this.y = floorY; this.dy = 0; } }
            if (this.x > canvas.width) this.x = 0; if (this.x < 0) this.x = canvas.width;
        }
        draw() {
            ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            let color = '#00eaff', label = 'S';
            if (this.type === 'shield') { color = '#ffeb3b'; label = 'D'; }
            if (this.type === 'double') { color = '#ff4081'; label = '2x'; }
            if (this.type === 'megaflap') { color = '#8bc34a'; label = 'F'; }
            ctx.fillStyle = color; ctx.shadowColor = color; ctx.shadowBlur = 10; ctx.fill(); ctx.restore();
            ctx.font = 'bold 12px sans-serif'; ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.fillText(label, this.x, this.y + 5);
        }
    }

    class Knight {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.width = 40; this.height = 45; this.dx = 0; this.dy = 0; this.type = type;
            this.riderColor = type === 'player' ? '#f0a048' : '#c0c0c0'; this.riderHighlight = type === 'player' ? '#FAD7A0' : '#FDFEFE';
            this.birdBodyColor = type === 'player' ? '#D4AC0D' : '#27AE60'; this.birdBodyHighlight = type === 'player' ? '#F1C40F' : '#2ECC71';
            this.lanceColor = type === 'player' ? '#ffcc00' : '#e0e0e0';
            this.onPlatform = false; this.direction = 1; this.isDefeated = false;
            this.respawnTimer = 0; this.animFrame = 0;
        }
        
        draw() {
            if (this.isDefeated) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            if (this.direction === -1) ctx.scale(-1, 1);

            const isWalking = this.onPlatform && Math.abs(this.dx) > 0.1;
            const legFrame = isWalking ? Math.sin(this.animFrame * 0.5) * 6 : 0;

            // Legs
            ctx.fillStyle = '#4A235A';
            ctx.fillRect(-8 + legFrame, 18, 4, 8); // Back leg
            ctx.fillRect(4 - legFrame, 18, 4, 8); // Front leg

            // Body
            ctx.fillStyle = this.birdBodyColor;
            ctx.beginPath();
            ctx.ellipse(0, 10, 20, 14, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = this.birdBodyHighlight; // Highlight
            ctx.beginPath();
            ctx.ellipse(0, 6, 18, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Neck
            ctx.fillStyle = this.birdBodyColor;
            ctx.beginPath();
            ctx.moveTo(-5, 0);
            ctx.quadraticCurveTo(-15, -15, -10, -20);
            ctx.quadraticCurveTo(-5, -12, 0, 0);
            ctx.fill();

            // Head
            ctx.fillStyle = this.birdBodyColor;
            ctx.beginPath();
            ctx.arc(-12, -22, 8, 0, Math.PI * 2);
            ctx.fill();
            // Beak
            ctx.fillStyle = '#F39C12';
            ctx.beginPath();
            ctx.moveTo(-18, -22); ctx.lineTo(-28, -24); ctx.lineTo(-28, -20); ctx.closePath();
            ctx.fill();

            // Wings
            let wingAngle = 0;
            if (!isWalking) {
                const flapSequence = [0.5, 1, 0.5, 0, -0.5, -1, -0.5, 0];
                wingAngle = flapSequence[Math.floor(this.animFrame * 0.5) % flapSequence.length] * 0.6;
            }
            ctx.fillStyle = this.birdBodyHighlight;
            ctx.save();
            ctx.translate(0, 10);
            ctx.rotate(wingAngle);
            ctx.beginPath();
            ctx.ellipse(0, 0, 22, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // --- Rider Drawing ---
            ctx.fillStyle = this.riderColor;
            ctx.fillRect(-6, -15, 12, 20); // Torso
            ctx.fillStyle = this.riderHighlight;
            ctx.fillRect(-4, -15, 4, 20);
            
            ctx.fillStyle = this.riderColor;
            ctx.beginPath();
            ctx.arc(0, -22, 8, 0, Math.PI * 2); // Head
            ctx.fill();
            ctx.fillStyle = this.riderHighlight;
            ctx.beginPath();
            ctx.arc(-2, -24, 4, 0, Math.PI * 2);
            ctx.fill();

            // Lance
            ctx.strokeStyle = this.lanceColor; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(45, -5); ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.fillRect(45, -7, 3, 4);

            ctx.restore();
        }

        update() {
            if (this.isDefeated) { this.respawnTimer -= 1000 / 60; if (this.respawnTimer <= 0) this.respawn(); return; }
            this.dy += GRAVITY; this.dx *= FRICTION; this.x += this.dx; this.y += this.dy; this.animFrame++;
            if (Math.abs(this.dx) > 0.1) this.direction = this.dx > 0 ? 1 : -1;
            if (this.x > canvas.width + this.width/2) this.x = -this.width/2; if (this.x < -this.width/2) this.x = canvas.width + this.width/2;
            this.onPlatform = false;
            platforms.forEach(p => { if (this.y+this.height/2>p.y && this.y-this.height/2<p.y+p.height && this.x+this.width/2>p.x && this.x-this.width/2<p.x+p.width) { if (this.dy > 0 && (this.y + this.height/2 - this.dy) <= p.y) { this.y = p.y - this.height/2; this.dy = 0; this.onPlatform = true; } } });
            if (this.y > canvas.height - this.height/2 - 20) { if(this.type === 'player') this.defeat(); else { const i = enemies.indexOf(this); if (i > -1) enemies.splice(i, 1); } createExplosion(this.x, this.y, '255, 80, 80'); }
        }
        flap() { if (this.onPlatform || this.dy > -FLAP_FORCE * 0.5) { this.dy = FLAP_FORCE; sound.playFlap(); } }
        defeat() {
            if (this.type === 'player') {
                if (playerShielded) { playerShielded = false; return; }
                lives--;
                updateScore();
                if (lives <= 0) { gameOver = true; } 
                else { this.isDefeated = true; this.respawnTimer = RESPAWN_TIME; createExplosion(this.x, this.y, '240, 160, 72'); sound.playPlayerDefeat(); }
            } else {
                let points = playerDoublePoints ? 200 : 100;
                score += points;
                eggs.push(new Egg(this.x, this.y));
                const i = enemies.indexOf(this); if (i > -1) enemies.splice(i, 1);
                createExplosion(this.x, this.y, '80, 200, 120'); sound.playDefeat();
            }
            updateScore();
        }
        respawn() { this.isDefeated = false; this.x = Math.random() * canvas.width; this.y = 50; this.dx = 0; this.dy = 0; }
    }

    function updateEnemyAI(enemy, target) {
        if (enemy.isDefeated) return;
        if (Math.random() < 0.02) enemy.flap();
        if (target.y < enemy.y && enemy.y > canvas.height * 0.5 && Math.random() < 0.03) enemy.flap();
        const targetX = target.isDefeated ? canvas.width / 2 : target.x;
        const speed = (enemy.speedBoost || 1);
        if (targetX > enemy.x) enemy.dx += (0.15 + Math.random() * 0.1) * speed; else enemy.dx -= (0.15 + Math.random() * 0.1) * speed;
        enemy.dx = Math.max(-MOVE_SPEED * speed, Math.min(MOVE_SPEED * speed, enemy.dx));
    }

    function checkCollisions() {
        enemies.forEach(enemy => {
            if (player.isDefeated || enemy.isDefeated) return;
            const dx = player.x - enemy.x; const dy = player.y - enemy.y; const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < player.width/2 + enemy.width/2) { if (player.y < enemy.y - 5) { enemy.defeat(); player.dy = -4; } else { player.defeat(); enemy.dy = -4; } }
        });
        eggs.forEach((egg, i) => { const dx = player.x-(egg.x+egg.width/2); const dy = player.y-(egg.y+egg.height/2); const dist = Math.sqrt(dx*dx + dy*dy); if (dist < player.width/2 + egg.width) { score += 25; eggs.splice(i, 1); sound.playEggCollect(); updateScore(); } });
        powerUps.forEach((pu, idx) => {
            const dx = player.x - pu.x; const dy = player.y - pu.y; const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < player.width/2 + pu.size) {
                if (pu.type === 'speed') { playerSpeedBoost = 2; speedBoostTimer = 300; }
                if (pu.type === 'shield') { playerShielded = true; playerShieldTimer = 300; }
                if (pu.type === 'double') { playerDoublePoints = true; playerDoubleTimer = 300; }
                if (pu.type === 'megaflap') { playerMegaFlap = true; playerMegaFlapTimer = 200; }
                powerUps.splice(idx, 1);
            }
        });
    }
    
    function createExplosion(x, y, color) { for (let i = 0; i < 30; i++) particles.push(new Particle(x, y, color)); }
    function updateScore() { scoreBoard.textContent = `SCORE: ${score} | WAVE: ${wave} | LIVES: ${lives}`; }
    function checkWaveCompletion() { if (enemies.length === 0 && eggs.length === 0 && waveMessage.alpha <= 0) { wave++; startWave(wave); } }

    function startWave(waveNumber) {
        enemies = []; eggs = []; powerUps = [];
        const enemyCount = 2 + waveNumber;
        const enemySpeedBoost = 1 + waveNumber * 0.05;
        for (let i = 0; i < enemyCount; i++) { const enemy = new Knight(randomRange(50, canvas.width - 50), randomRange(50, 200), 'enemy'); enemy.speedBoost = enemySpeedBoost; enemies.push(enemy); }
        if (Math.random() < 0.3 + waveNumber * 0.05) {
            const p = platforms[Math.floor(Math.random() * platforms.length)];
            let types = ['speed'];
            if (waveNumber > 2) types.push('shield'); if (waveNumber > 4) types.push('double'); if (waveNumber > 6) types.push('megaflap');
            powerUps.push(new PowerUp(randomRange(p.x + 20, p.x + p.width - 20), p.y - 18, types[Math.floor(Math.random() * types.length)]));
        }
        waveMessage = { text: `WAVE ${waveNumber}`, alpha: 1, timer: 120 };
        updateScore();
    }

    function init() {
        canvas.height = 600; canvas.width = 800;
        platforms = [ { x: 100, y: canvas.height - 150, width: 200, height: 20 }, { x: canvas.width - 300, y: canvas.height - 150, width: 200, height: 20 }, { x: canvas.width / 2 - 150, y: canvas.height / 2, width: 300, height: 20 }, { x: 0, y: 200, width: 150, height: 20 }, { x: canvas.width - 150, y: 200, width: 150, height: 20 } ];
        player = new Knight(100, 100, 'player');
        score = 0; wave = 1; lives = 3; gameOver = false;
        startWave(wave);
    }
    
    function drawPlatform(p) { ctx.fillStyle = '#6D4C41'; ctx.fillRect(p.x, p.y, p.width, p.height); ctx.fillStyle = '#8D6E63'; ctx.fillRect(p.x, p.y, p.width, p.height / 3); ctx.fillStyle = 'rgba(0,0,0,0.1)'; for(let i = 0; i < p.width / 10; i++) { ctx.fillRect(p.x + i * 10 + Math.random() * 5, p.y + Math.random() * p.height, 5, 5); } }
    function drawLava() { ctx.fillStyle = '#d44'; ctx.fillRect(0, canvas.height - 20, canvas.width, 20); for(let i = 0; i < canvas.width / 30; i++) { const x = (i * 30 + frameCount * 0.5) % canvas.width; const y = canvas.height - 10 + Math.sin(frameCount * 0.1 + i) * 5; const radius = 2 + Math.sin(frameCount * 0.05 + i) * 2; ctx.fillStyle = `rgba(255, 165, 0, ${0.5 + Math.sin(frameCount * 0.1 + i) * 0.2})`; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill(); } }

    function gameLoop() {
        if (gameOver) {
            document.getElementById('game-over').style.display = 'block';
            return; 
        }
        frameCount++; 
        handleInput();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLava(); platforms.forEach(drawPlatform);
        if (speedBoostTimer > 0) speedBoostTimer--; else playerSpeedBoost = 1;
        if (playerShieldTimer > 0) playerShieldTimer--; else playerShielded = false;
        if (playerDoubleTimer > 0) playerDoubleTimer--; else playerDoublePoints = false;
        if (playerMegaFlapTimer > 0) playerMegaFlapTimer--; else playerMegaFlap = false;
        player.update(); player.draw();
        enemies.forEach(e => { updateEnemyAI(e, player); e.update(); e.draw(); });
        eggs.forEach(e => { e.update(); e.draw(); });
        powerUps.forEach(pu => { pu.update(); pu.draw(); });
        particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });
        if (waveMessage.alpha > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${waveMessage.alpha})`; ctx.font = '32px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.fillText(waveMessage.text, canvas.width / 2, canvas.height / 2 - 50); waveMessage.timer--; if(waveMessage.timer <= 0) { waveMessage.alpha -= 0.02; } }
        checkCollisions(); checkWaveCompletion();
        requestAnimationFrame(gameLoop);
    }

    const keys = { "ArrowUp": false, "ArrowLeft": false, "ArrowRight": false, "r": false, "R": false };
    
    function restartGame() {
        document.getElementById('game-over').style.display = 'none';
        init();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => {
        const key = e.key;
        if (keys.hasOwnProperty(key)) {
            e.preventDefault();
            keys[key] = true;
        }
        if (key.toLowerCase() === 'r' && gameOver) {
            restartGame();
        }
    });
    window.addEventListener('keyup', (e) => {
        const key = e.key;
        if (keys.hasOwnProperty(key)) {
            e.preventDefault();
            keys[key] = false;
        }
    });
    
    function handleInput() {
        if (player.isDefeated || gameOver) return;
        if (keys.ArrowUp) { if (playerMegaFlap) { player.dy = FLAP_FORCE * 1.7; sound.playFlap(); } else { player.flap(); } }
        if (keys.ArrowLeft) player.dx -= 0.8 * playerSpeedBoost;
        if (keys.ArrowRight) player.dx += 0.8 * playerSpeedBoost;
        player.dx = Math.max(-MOVE_SPEED * playerSpeedBoost, Math.min(MOVE_SPEED * playerSpeedBoost, player.dx));
    }

    window.addEventListener('resize', init);
    init();
    gameLoop();

</script>
</body>
</html>
