<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EggWar</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0a0a0a;
            font-family: 'Press-Start-2P', cursive;
            color: white;
            overflow: hidden;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            border: 4px solid #444;
            border-radius: 10px;
            background: #111;
            padding: 20px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }
        canvas {
            background-color: #000;
            border: 2px solid #55e;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(85, 85, 238, 0.5);
            max-width: 100%;
            max-height: 80vh;
            aspect-ratio: 4 / 3;
            cursor: pointer;
        }
        .controls {
            margin-top: 15px;
            font-size: 1em;
            color: #ccc;
        }
        .score-board {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #ffcc00;
            text-shadow: 2px 2px #d40000;
        }
    </style>
</head>
<body>

<div class="game-container">
    <div id="score-board" class="score-board">SCORE: 0 | WAVE: 1 | LIVES: 3</div>
    <div id="game-over" style="display:none; color:#ff4444; font-size:2em; margin-top:20px;">GAME OVER!<br>Press R to restart.</div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">Click Screen to Start Sound | Arrows: ← Left | → Right | ↑ Flap</div>
</div>

<script>
    // --- Canvas and Context Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('score-board');

    // --- Game Constants ---
    const GRAVITY = 0.25;
    const FLAP_FORCE = -6.5;
    const MOVE_SPEED = 4;
    const FRICTION = 0.92;
    const RESPAWN_TIME = 2000; 
    const EGG_HATCH_TIME = 5000;

    // --- Game State ---
    let platforms = [];
    let player;
    let powerUps = [];
    let enemies = [];
    let eggs = [];
    let particles = [];
    let score = 0;
    let wave = 1;
let lives = 9;
let gameOver = false;
    let frameCount = 0;
    let soundReady = false;
    let lastFlapTime = 0; // Cooldown timer for flap sound
    let lastDefeatTime = 0; // Cooldown timer for defeat sound
    let playerSpeedBoost = 1;
let playerShielded = false;
let playerShieldTimer = 0;
let playerDoublePoints = false;
let playerDoubleTimer = 0;
let playerMegaFlap = false;
let playerMegaFlapTimer = 0;
    let speedBoostTimer = 0;
    // --- Sound Engine ---
    // Create reverb effect
    const reverb = new Tone.Reverb({ decay: 2, preDelay: 0.1 }).toDestination();
    // Create synths and connect to reverb
    const flapSynth = new Tone.MembraneSynth({
        pitchDecay: 0.01,
        octaves: 4,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 }
    }).connect(reverb);
    const defeatSynth = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.01, decay: 0.08, sustain: 0, release: 0.05 }
    }).connect(reverb);
    defeatSynth.volume.value = -12;
    const defeatLayerSynth = new Tone.Synth({
        oscillator: { type: 'square' },
        envelope: { attack: 0.02, decay: 0.08, sustain: 0, release: 0.05 }
    }).connect(reverb);
    defeatLayerSynth.volume.value = -10;
    const eggSynth = new Tone.Synth({
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 }
    }).connect(reverb);
    const playerDefeatSynth = new Tone.MetalSynth({
        frequency: 100,
        envelope: { attack: 0.001, decay: 0.4, release: 0.2 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
    }).connect(reverb);

    const sound = {
        flapSynth,
        defeatSynth,
        defeatLayerSynth,
        eggSynth,
        playerDefeatSynth,

        playFlap: () => {
            if (!soundReady) return;
            const now = Tone.now();
            // Add a 50ms cooldown to prevent Tone.js errors from rapid calls
            if (now > lastFlapTime + 0.05) {
                // Randomize pitch and velocity
                const note = Math.random() > 0.5 ? 'C2' : 'D2';
                const velocity = 0.7 + Math.random() * 0.3;
                sound.flapSynth.triggerAttackRelease(note, '8n', now, velocity);
                lastFlapTime = now;
            }
        },
        playDefeat: () => {
            if(soundReady) {
                const now = Tone.now();
                // Add a 100ms cooldown to prevent Tone.js errors from rapid calls
                if (now > lastDefeatTime + 0.1 && now > lastDefeatTime) {
                    try {
                        sound.defeatSynth.triggerAttackRelease('0.1', undefined, now);
                        // Randomize pitch for layer
                        const defeatNote = Math.random() > 0.5 ? 'C3' : 'G2';
                        sound.defeatLayerSynth.triggerAttackRelease(defeatNote, '16n', now, 0.6 + Math.random() * 0.4);
                        lastDefeatTime = now;
                    } catch (e) {
                        // Prevent crash, skip sound if Tone.js throws
                        lastDefeatTime = now;
                    }
                }
            }
        },
        playEggCollect: () => {
            if(soundReady) {
                const now = Tone.now();
                // Randomize note and velocity for variety
                const notes = ['G5', 'A5', 'E5'];
                const note = notes[Math.floor(Math.random() * notes.length)];
                const velocity = 0.7 + Math.random() * 0.3;
                sound.eggSynth.triggerAttackRelease(note, '8n', now, velocity);
            }
        },
        playPlayerDefeat: () => {
            if(soundReady) {
                const now = Tone.now();
                // Add a 100ms cooldown to prevent Tone.js errors from rapid calls
                if (now > lastDefeatTime + 0.1 && now > lastDefeatTime) {
                    try {
                        sound.playerDefeatSynth.frequency.value = 80 + Math.random() * 40;
                        sound.playerDefeatSynth.triggerAttackRelease(0.1, undefined, now);
                        lastDefeatTime = now;
                    } catch (e) {
                        // Prevent crash, skip sound if Tone.js throws
                        lastDefeatTime = now;
                    }
                }
            }
        }
    };
    
    // Try to start audio automatically on page load
    window.addEventListener('DOMContentLoaded', async () => {
        if (!soundReady) {
            try {
                await Tone.start();
                soundReady = true;
                console.log('Audio is ready');
            } catch (e) {
                console.warn('Audio auto-start blocked by browser. Click to enable.');
            }
        }
    });
    // Fallback: still allow click to start audio if needed
    canvas.addEventListener('click', async () => {
        if (!soundReady) {
            await Tone.start();
            soundReady = true;
            console.log('Audio is ready');
        }
    });


    // --- Utility Functions ---
    function randomRange(min, max) { return Math.random() * (max - min) + min; }

    // --- Game Object Classes ---
    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.size = Math.random() * 5 + 2;
            this.dx = randomRange(-3, 3); this.dy = randomRange(-5, 2);
            this.life = 1;
        }
        update() {
            this.x += this.dx; this.y += this.dy;
            this.dy += GRAVITY * 0.5; this.life -= 0.03;
        }
        draw() {
            ctx.fillStyle = `rgba(${this.color}, ${this.life})`;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        }
    }
    
    class Egg {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 15; this.height = 20;
            this.dx = randomRange(-2, 2); this.dy = -2;
            this.hatchTimer = EGG_HATCH_TIME;
        }
        update() {
            this.dy += GRAVITY; this.x += this.dx; this.y += this.dy;
            this.dx *= 0.98;
            platforms.forEach(p => {
                 if (this.y+this.height>p.y && this.y<p.y+p.height && this.x+this.width>p.x && this.x<p.x+p.width) {
                    if (this.dy > 0) { this.y = p.y - this.height; this.dy *= -0.5; }
                }
            });
            if (this.y > canvas.height - this.height - 20) { this.y = canvas.height - this.height - 20; this.dy *= -0.5; }
            if (this.x > canvas.width) this.x = 0; if (this.x < 0) this.x = canvas.width;
            this.hatchTimer -= 1000 / 60;
            if (this.hatchTimer <= 0) this.hatch();
        }
        draw() {
            ctx.fillStyle = '#E0E0E0'; ctx.strokeStyle = '#A0A0A0'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
        }
        hatch() {
            enemies.push(new Knight(this.x, this.y, 'enemy'));
            const index = eggs.indexOf(this);
            if (index > -1) eggs.splice(index, 1);
        }
    }

class PowerUp {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.size = 18;
        this.type = type;
        this.dy = -2;
    }
    update() {
        this.dy += GRAVITY; this.y += this.dy;
        // Platform collision
        let onPlatform = false;
        for (let p of platforms) {
            if (
                this.x > p.x && this.x < p.x + p.width &&
                this.y + this.size > p.y && this.y < p.y + p.height
            ) {
                // Rest on top of platform
                this.y = p.y - this.size;
                this.dy = 0;
                onPlatform = true;
                break;
            }
        }
        // Stop at top of lava if not on platform
        if (!onPlatform) {
            const floorY = canvas.height - 20 - this.size;
            if (this.y > floorY) {
                this.y = floorY;
                this.dy = 0;
            }
        }
        if (this.x > canvas.width) this.x = 0; if (this.x < 0) this.x = canvas.width;
    }
    draw() {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        // Color and label by type
        let color = '#00eaff', label = 'S';
        if (this.type === 'shield') { color = '#ffeb3b'; label = 'D'; }
        if (this.type === 'double') { color = '#ff4081'; label = '2x'; }
        if (this.type === 'megaflap') { color = '#8bc34a'; label = 'F'; }
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.restore();
        ctx.font = 'bold 12px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(label, this.x, this.y + 5);
    }
}

    class Knight {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.width = 40; this.height = 45;
            this.dx = 0; this.dy = 0; this.type = type;
            this.riderColor = type === 'player' ? '#f0a048' : '#c0c0c0';
            this.birdBodyColor = type === 'player' ? '#D4AC0D' : '#50c878';
            this.birdWingColor = type === 'player' ? '#F1C40F' : '#58D68D';
            this.lanceColor = type === 'player' ? '#ffcc00' : '#e0e0e0';
            this.onPlatform = false; this.direction = 1; this.isDefeated = false;
            this.respawnTimer = 0; this.flapFrame = 0; this.walking = false;
        }

        draw() {
            if (this.isDefeated) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            if (this.direction === -1) ctx.scale(-1, 1);

            const isWalking = this.onPlatform && Math.abs(this.dx) > 0.1;
            const legFrame = isWalking ? Math.sin(frameCount * 0.5) * 5 : 0;

            // Legs
            ctx.strokeStyle = '#4A235A'; ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(-5, 10); ctx.lineTo(-8 + legFrame, 20); // Back leg
            ctx.moveTo(5, 10); ctx.lineTo(8 - legFrame, 20); // Front leg
            ctx.stroke();
            
            // Bird Body
            ctx.fillStyle = this.birdBodyColor;
            ctx.beginPath();
            ctx.ellipse(0, 5, 18, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wings
            const wingY = this.walking ? 0 : Math.sin(this.flapFrame) * 8;
            ctx.fillStyle = this.birdWingColor;
            ctx.beginPath();
            ctx.moveTo(-10, 5);
            ctx.quadraticCurveTo(0, 5 + wingY, 15, 5);
            ctx.quadraticCurveTo(0, 15 + wingY, -10, 5);
            ctx.fill();

            // Head
            ctx.fillStyle = this.birdBodyColor;
            ctx.beginPath();
            ctx.arc(-15, -5, 8, 0, Math.PI * 2);
            ctx.fill();
            // Beak
            ctx.fillStyle = '#F39C12';
            ctx.beginPath();
            ctx.moveTo(-22, -5); ctx.lineTo(-32, -7); ctx.lineTo(-32, -3); ctx.closePath();
            ctx.fill();

            // Rider
            ctx.fillStyle = this.riderColor;
            ctx.fillRect(-5, -25, 10, 20); // Torso
            ctx.beginPath();
            ctx.arc(0, -30, 7, 0, Math.PI * 2); // Head
            ctx.fill();

            // Lance
            ctx.strokeStyle = this.lanceColor; ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(10, -15); ctx.lineTo(40, -15);
            ctx.stroke();

            ctx.restore();
        }

        update() {
            if (this.isDefeated) {
                this.respawnTimer -= 1000 / 60;
                if (this.respawnTimer <= 0) this.respawn();
                return;
            }

            this.dy += GRAVITY; this.dx *= FRICTION;
            this.x += this.dx; this.y += this.dy;
            this.flapFrame += 0.3;
            if (Math.abs(this.dx) > 0.1) this.direction = this.dx > 0 ? 1 : -1;
            if (this.x > canvas.width + this.width/2) this.x = -this.width/2;
            if (this.x < -this.width/2) this.x = canvas.width + this.width/2;

            this.onPlatform = false;
            platforms.forEach(p => {
                if (this.y+this.height/2>p.y && this.y-this.height/2<p.y+p.height && this.x+this.width/2>p.x && this.x-this.width/2<p.x+p.width) {
                    if (this.dy > 0 && (this.y + this.height/2 - this.dy) <= p.y) {
                        this.y = p.y - this.height/2; this.dy = 0; this.onPlatform = true;
                    }
                }
            });

            if (this.y > canvas.height - this.height/2 - 20) {
                if(this.type === 'player') this.defeat();
                else { const index = enemies.indexOf(this); if (index > -1) enemies.splice(index, 1); }
                createExplosion(this.x, this.y, '255, 80, 80');
            }
        }

        flap() {
            if (this.onPlatform || this.dy > -FLAP_FORCE * 0.5) {
                this.dy = FLAP_FORCE;
                sound.playFlap();
            }
        }

        defeat() {
            if (this.type === 'player') {
                this.isDefeated = true; this.respawnTimer = RESPAWN_TIME;
                createExplosion(this.x, this.y, '240, 160, 72');
                score = Math.max(0, score - 50);
                sound.playPlayerDefeat();
                updateScore();
            } else {
                eggs.push(new Egg(this.x, this.y));
                const index = enemies.indexOf(this);
                if (index > -1) enemies.splice(index, 1);
                createExplosion(this.x, this.y, '80, 200, 120');
                sound.playDefeat();
            }
        }

        respawn() {
            this.isDefeated = false; this.x = Math.random() * canvas.width; this.y = 50;
            this.dx = 0; this.dy = 0;
        }
    }

    function updateEnemyAI(enemy, target) {
        if (enemy.isDefeated) return;
        // More varied AI
        if (Math.random() < 0.02) enemy.flap(); // Random flap
        if (target.y < enemy.y && enemy.y > canvas.height * 0.5 && Math.random() < 0.03) enemy.flap(); // Flap if player is above

        // --- Collision avoidance ---
        // Allow clustering if global flag is set
        if (!window.allowEnemyClustering) {
            enemies.forEach(other => {
                if (other !== enemy && !other.isDefeated) {
                    const dx = enemy.x - other.x;
                    const dy = enemy.y - other.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 40) { // Repel if too close
                        enemy.dx += dx * 0.01;
                        enemy.dy += dy * 0.01;
                    }
                }
            });
        }

    const targetX = target.isDefeated ? canvas.width / 2 : target.x;
    const speed = (enemy.speedBoost || 1);
    if (targetX > enemy.x) enemy.dx += (0.15 + Math.random() * 0.1) * speed;
    else enemy.dx -= (0.15 + Math.random() * 0.1) * speed;
    enemy.dx = Math.max(-MOVE_SPEED * speed, Math.min(MOVE_SPEED * speed, enemy.dx));
    }

    function checkCollisions() {
        enemies.forEach(enemy => {
            if (player.isDefeated || enemy.isDefeated) return;
            const dx = player.x - enemy.x; const dy = player.y - enemy.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            if (distance < player.width/2 + enemy.width/2) {
                if (player.y < enemy.y - 5) {
                    let points = 100;
                    if (playerDoublePoints) points *= 2;
                    score += points; enemy.defeat(); player.dy = -4;
                } else {
                    if (!playerShielded) {
                        lives--;
                        updateScore();
                        if (lives <= 0) {
                            gameOver = true;
                        } else {
                            player.defeat();
                        }
                    }
                    enemy.dy = -4;
                }
                updateScore();
            }
        });
        eggs.forEach((egg, index) => {
             const dx = player.x-(egg.x+egg.width/2); const dy = player.y-(egg.y+egg.height/2);
             const distance = Math.sqrt(dx*dx + dy*dy);
             if (distance < player.width/2 + egg.width) {
                 score += 25; eggs.splice(index, 1);
                 sound.playEggCollect();
                 updateScore();
             }
        });
        // Power-up collision
        powerUps.forEach((pu, idx) => {
            const dx = player.x - pu.x;
            const dy = player.y - pu.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < player.width/2 + pu.size) {
                if (pu.type === 'speed') {
                    playerSpeedBoost = 2;
                    speedBoostTimer = 300; // frames (~5s)
                }
                if (pu.type === 'shield') {
                    playerShielded = true;
                    playerShieldTimer = 300;
                }
                if (pu.type === 'double') {
                    playerDoublePoints = true;
                    playerDoubleTimer = 300;
                }
                if (pu.type === 'megaflap') {
                    playerMegaFlap = true;
                    playerMegaFlapTimer = 200;
                }
                powerUps.splice(idx, 1);
            }
        });
    }
    
    function createExplosion(x, y, color) {
        for (let i = 0; i < 30; i++) particles.push(new Particle(x, y, color));
    }

    function updateScore() {
    scoreBoard.textContent = `SCORE: ${score} | WAVE: ${wave} | LIVES: ${lives}`;
    }
    
    function checkWaveCompletion() {
        if (enemies.length === 0 && eggs.length === 0) {
            wave++; startWave(wave); updateScore();
        }
    }

    function startWave(waveNumber) {
    enemies = []; eggs = [];
    powerUps = [];
        // Increase enemy count and speed with wave
        const enemyCount = 2 + waveNumber + Math.floor(waveNumber/2);
        const enemySpeedBoost = 1 + waveNumber * 0.1;
        // Spread out spawn positions horizontally
        const minX = 50, maxX = canvas.width - 50;
        const spacing = (maxX - minX) / Math.max(1, enemyCount - 1);
        for (let i = 0; i < enemyCount; i++) {
            let x = minX + i * spacing + randomRange(-20, 20);
            let y = randomRange(50, 200);
            const enemy = new Knight(x, y, 'enemy');
            enemy.speedBoost = enemySpeedBoost;
            enemies.push(enemy);
        }
    // Power-ups increase with wave number to balance difficulty
    const powerUpCount = 1 + Math.floor(waveNumber / 2);
        // Unlock more power-up types as waves increase
        let types = ['speed'];
        if (waveNumber > 2) types.push('shield');
        if (waveNumber > 4) types.push('double');
        if (waveNumber > 6) types.push('megaflap');
        for (let i = 0; i < powerUpCount; i++) {
            // Pick a random platform
            const platform = platforms[Math.floor(Math.random() * platforms.length)];
            // Place power-up randomly along platform width
            let x = randomRange(platform.x + 20, platform.x + platform.width - 20);
            let y = platform.y - 18; // 18 is power-up radius, so it sits on top
            // Pick a random type from unlocked types
            let type = types[Math.floor(Math.random() * types.length)];
            powerUps.push(new PowerUp(x, y, type));
        }
    }

    function init() {
        canvas.height = 600; canvas.width = 800;
        platforms = [
            { x: 100, y: canvas.height - 150, width: 200, height: 20 },
            { x: canvas.width - 300, y: canvas.height - 150, width: 200, height: 20 },
            { x: canvas.width / 2 - 150, y: canvas.height / 2, width: 300, height: 20 },
            { x: 0, y: 200, width: 150, height: 20 },
            { x: canvas.width - 150, y: 200, width: 150, height: 20 }
        ];
        player = new Knight(100, 100, 'player');
        score = 0; wave = 1; startWave(wave); updateScore();
    }

    function gameLoop() {
        if (gameOver) {
            document.getElementById('game-over').style.display = '';
            return;
        } else {
            document.getElementById('game-over').style.display = 'none';
        }
        // Power-up timers
        if (playerShielded) {
            playerShieldTimer--;
            if (playerShieldTimer <= 0) playerShielded = false;
        }
        if (playerDoublePoints) {
            playerDoubleTimer--;
            if (playerDoubleTimer <= 0) playerDoublePoints = false;
        }
        if (playerMegaFlap) {
            playerMegaFlapTimer--;
            if (playerMegaFlapTimer <= 0) playerMegaFlap = false;
        }
        frameCount++;
        handleInput();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#d44';
        ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
        
        ctx.fillStyle = '#7b583f';
        platforms.forEach(p => { ctx.fillRect(p.x, p.y, p.width, p.height); });

        // Power-up timer logic
        if (playerSpeedBoost > 1) {
            speedBoostTimer--;
            if (speedBoostTimer <= 0) playerSpeedBoost = 1;
        }
        player.update(); player.draw();
        enemies.forEach(e => { updateEnemyAI(e, player); e.update(); e.draw(); });
        eggs.forEach(e => { e.update(); e.draw(); });
        powerUps.forEach(pu => { pu.update(); pu.draw(); });
        particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });

        checkCollisions(); checkWaveCompletion();
        requestAnimationFrame(gameLoop);
    }

    const keys = { ArrowUp: false, ArrowLeft: false, ArrowRight: false };
    window.addEventListener('keydown', (e) => { if (keys[e.key] !== undefined) { e.preventDefault(); keys[e.key] = true; } });
    window.addEventListener('keyup', (e) => { if (keys[e.key] !== undefined) { e.preventDefault(); keys[e.key] = false; } });
    
    function handleInput() {
        // Restart game if game over
        if (gameOver && keys['r']) {
            lives = 3;
            score = 0;
            wave = 1;
            gameOver = false;
            updateScore();
            init();
        }
    if (player.isDefeated) return;
        if (keys.ArrowUp) {
            if (playerMegaFlap) {
                player.dy = FLAP_FORCE * 1.7;
                sound.playFlap();
            } else {
                player.flap();
            }
        }
    if (keys.ArrowLeft) player.dx -= 0.8 * playerSpeedBoost;
    if (keys.ArrowRight) player.dx += 0.8 * playerSpeedBoost;
    player.dx = Math.max(-MOVE_SPEED * playerSpeedBoost, Math.min(MOVE_SPEED * playerSpeedBoost, player.dx));
    }

    window.addEventListener('resize', init);
    init();
    gameLoop();

</script>
</body>
</html>
